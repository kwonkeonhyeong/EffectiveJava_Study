※ 책 내용을 바탕으로 제 관점에서 풀어 쓴 글입니다. 일부 내용이 다를 수 있습니다.

## 아이템 10 - equals는 일반 규약을 지켜 재정의하라

equals() 메서드는 두 참조 변수가 동일한 값을 가지는지 여부를 비교하기 위해 사용된다. 객체의 논리적 동치성을 판단할 때 반드시 일반 규약을 지키며 재정의해야 한다.

---

### equals 메서드, 언제 재정의해야 할까?

재정의 하지 않아도 되는 경우

1.  `고유 ID를 가지는 경우`  
    각 인스턴스가 고유한 ID를 가지며, 논리적 동치성 검사가 필요 없는 경우
2.  `상위 클래스의 구현이 적절한 경우`    
    상위 클래스의 equals가 이미 논리적 동치성을 정확히 구현한 경우
3.  `외부 호출이 없는 경우`  
    클래스가 private 또는 package-private 범위로 제한되어 외부에서 동치성 비교가 필요하지 않은 경우

재정의가 필요한 경우

-   `객체의 내부 상태(필드 값)가 같을 때 동일한 객체로 간주해야 하는 경우`  
     이 경우, 논리적 동치성 비교하기 위해 반드시 equals 메서드를 재정의해야 한다.

---

### equals의 일반 규약

-   `반사성 (Reflexivity)`  
    모든 null이 아닌 참조 값 x에 대해 x.equals(x)는 항상 true를 반환해야 한다.  
    객체는 자기 자신과 같아야 한다는 기본적인 원칙이다. 이를 위반하면, 컬렉션의 contains 메서드와 같은 동작에서 예기치 못한 결과가 발생할 수 있다.
-   `대칭성 (Symmetry)`  
    모든 null이 아닌 참조 값 x, y에 대해 x.equals(y)가 true라면, y.equals(x)도 반드시 true여야 한다.  
    이를 위반하면, 예를 들어 대소문자를 무시하는 문자열 비교와 같은 상황에서 일관성 없는 동작이 발생할 수 있다.
-   `추이성 (Transitivity)`  
    모든 null이 아닌 참조 값 x, y, z에 대해 x.equals(y)가 true이고, y.equals(z)도 true라면, x.equals(z)도 반드시 true여야 한다.  
    동치 관계는 일관성을 유지해야 하며, 이를 위반하면 컬렉션이나 정렬 알고리즘에서 예상치 못한 동작이 발생할 수 있다. 특히, 상속 구조에서 추가된 필드가 규약 위반의 원인이 될 수 있으므로 주의해야 한다.
-   `일관성 (Consistency)`  
    모든 null이 아닌 참조 값 x, y에 대해, 여러 번 호출된 x.equals(y)는 객체의 상태가 변경되지 않는 한 항상 동일한 값을 반환해야 한다.
-   `null-아님 (Non-nullity)`  
    모든 null이 아닌 참조 값 x에 대해 x.equals(null)은 항상 false를 반환해야 한다.  
    어떤 객체도 null과 같다고 판단되어서는 안 된다. 이는 기본적으로 안전한 동작을 보장하기 위한 규칙이다.

---

### equals의 전형적인 검사 패턴

-   `참조 비교`  
    == 연산자를 사용해 입력 값이 현재 객체와 동일한 참조인지 확인한다. 동일한 참조라면 추가적인 비교를 생략한다.
-   `타입 확인`  
    instanceof 연산자를 통해 입력 값이 기대하는 타입인지 명확히 검사한다.
-   `타입 캐스팅`  
    instanceof 검사를 통과한 경우, 입력 값을 올바른 타입으로 캐스팅한다.
-   `핵심 필드 비교`  
    두 객체의 핵심 필드 값들이 모두 일치하는지 확인한다.
-   `null 비교`  
    x.equals(null)은 항상 false를 반환해야 한다.
