## **item57: 자역변수의 범위를 최소화하라**

## **핵심정리**

지역변수의 범위를 줄이는 가장 강력한 기법은 역시 가장 처음에 쓰일 때 선언하기다. 

지역변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다. 

지역변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날 때까지 이므로, 실제 사용하는 블록 바깥에 선언된 변수는 그 블록이 끝날 때까지이므로, 실제 사용하는 브록 바깥에 선언된 변수는 그 블록이 끝난 뒤까지 살아 있게 된다. 

거의 모든 지역변수는 선언과 동시에 초기화해야 한다.

반복문은 독특한 방식으로 변수 범위를 최소화해준다. 

예전의 for 형태든 새로운 for-each 형태든, 반복문에서는 반복 변수(loop variable) 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다. 

**코드 57-1 컬렉션이나 배열을 순회하는 권장 관용구**
```java
for (Element e : c) {
        ... // e로 무언가를 한다. 
}
```

**코드 57-2 반복자가 필요할 때의 관용구**
```java
for(Iterator<Element> i = c.iterator(); i.hasNext()) {
    Element e = i.next();
}
```
다음의 두 while 문을 보면 앞서의 for 더 나은 이유를 알 수 있다. 

```java
Iterator<Element> i = c.iterator();
while(i.hasNext()) {
    doSomething(i.next());
}

Iterator<Element> i2 = c2.iterator();
while(i.hasNext()) {
    doSomethingElse(i2.next());    
}
```

두 번째 while 문에는 복사해 붙어녛기 오류가 있다. 새로운 반복 변수 i2를 초기화 했지만, 실수로 이전 while 문에서 쓴 i를 다시 쓴 것이다. 

불행히도 i의 유효범위는 아직 끝나지 않았으므로, 이 코드는 컴파일도 잘 되고 실행 시에 예외도 던지지 않는다. 

하지만 두 번쨰 while 문에는 복사해 붙여넣기 오류가 있다. 새로운 반복 변수 i2 초기화했지만, 실수로 이전 while 문에서 쓴 i를 다시 쓴 것이다. 

i의 유효 범위는 아직 끝나지 않았으므로, 이 코드는 컴파일도 잘되고 실행 시 예외도 던지지 않음. 

(for-each 포함한) for문 사용하면 이런 복사해 붙여넣기 오류를 컴파일 타임에 잡아준다. 

첫 번째 반복문이 사용한 원소와 반족자의 유효 범위가 반복문 종료와 함께 끝나기 때문이다. 

```java
for(Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    // e와 i로 무언가를 한다.
}

// 다음 코드는 "i를 찾을 수 없다"는 컴파일 오류를 낸다.
for(Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
    Element e2 = i2.next();
}
```

for문이 복사해 붙여넣기 오류를 줄여주는 이유는 또 있다. 
변수 유효 범위가 for문 범위와 일치하여 똑같은 이름의 변수를 여러 반복문에서 써도 서로 아무런 영향을 주지 않는다.

지역변수 범위를 최소화하는 마지막 방법은 **메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.**
